---
typora-root-url: ./
---

## Redis

<h5>基本概念

- Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此**读写速度非常快**，常用于**缓存，消息队列、分布式锁等场景**。

  > Redis 提供了多种数据类型来支持不同的业务场景，比如 String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是**原子性**的，因为执行命令由单线程负责的，不存在并发竞争的问题。
  >
  > 除此之外，Redis 还支持**事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制**等等。



- redis具备高性能和高并发两种特性



<h5>Redis数据结构及其应用场景

- String：缓存对象、常规计数、分布式锁、共享 session 信息等。
- Hash：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。
- List：缓存对象、购物车等。
- Set：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。
- Zset(有序集合)：排序场景，比如排行榜、电话和姓名排序等。



<h5>Redis线程模型

- redis单线程：**接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端**这个过程是由一个线程（主线程）来完成的。

  > Redis程序并不是单线程的。启动之后一般会开启以下几个线程：*处理关闭文件、AOF刷盘、异步释放Redis内存*。

- redis采用单线程快的原因

  - 大部分操作都在内存中完成。
  - 避免多线程之间的竞争。
  - 采用了 **I/O 多路复用机制**处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流。

  > 单线程程序是无法利用服务器的多核CPU。



<h5>Redis持久化

- redis重启后，内存中的数据会丢失，所以需要实现数据持久化，将数据存储到磁盘中。
- 持久化方式
  - AOF日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里。
  - RDB快照：将某一时刻的内存数据，以二进制的方式写入磁盘
  - 混合持久方式：集成了 AOF 和 RBD 的优点。
- 写时复制技术(COW)



<h5>Redis集群

- 主从复制：将从前的一台 Redis 服务器，同步数据到多台从 Redis 服务器上，且主从服务器之间采用的是「读写分离」的方式。

  > 主从服务器之间的命令复制是**异步**进行的。无法实现强一致性保证（主从数据时时刻刻保持一致），数据不一致是难以避免的。

- 哨兵模式：监控主从服务器，并且提供**主从节点故障转移的功能。**

- 切片集群：将数据分布在不同的服务器上，一次降低系统对单主节点的依赖。

- 集群脑裂：由于网络问题，集群节点之间失去联系。主从数据不同步；重新平衡选举，产生两个主服务。等网络恢复，旧主节点会降级为从节点，再与新主节点进行同步复制的时候，由于会从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。



<h5>过期删除与内存淘汰

- redis可以对key设置过期时间，需要有对应的机制将已过期的键值对删除。
- Redis 使用的过期删除策略是**惰性删除和定期删除**这两种策略配和使用。
  - 惰性删除：不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。
  - 定期删除：每隔一段时间随机从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。
- redis内存满了之后，会触发内存淘汰机制，阀值就是我们设置的最大运行内存。
- LRU与LFU

  - LRU：最近最少使用，会淘汰最近最少使用的数据。
  - LFU：最近最不常用的，根据数据访问次数来淘汰数据的。