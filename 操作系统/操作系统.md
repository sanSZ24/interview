## 操作系统

[TOC]

#### 进程与线程

##### 进程

- 进程：是计算机中的软件程序关于某数据集合上的一次运行活动，是系统进行资源分配的基本单位。

  > 进程和程序的区别
  >
  > - 进程是同时发生的，动态的；程序是指令的集合，静态的。
  > - 进程是暂时的，而程序是永久的。
  > - 一个程序可以由多个进程执行。
  > - 进程可以由另一个进程创建。

- 进程的控制结构：通过进程控制块（PCB，一种数据结构）来描述进程。**系统根据PCB而感知相应进程的存在，故说PCB是进程存在的唯一标识。**

  > 操作系统维护一张含有所有进程PCB的表。

- 进程的状态：**运行、就绪、阻塞**。

- 进程的上下文切换：就是要把一个进程挂起然后去执行另一个进程。

  > 需要保存旧进程的PCB，然后加载新进程的PCB，刷新缓存等。



##### 线程

- 线程：线程是比进程更小的、能够独立运行的单位，是调度的基本单位。

  > 线程**不拥有系统资源**，只有其运行所需的一些数据结构。**并且该线程与该进程内的其他线程共享该进程所拥有的全部资源**。

- 使用多线程的理由：

  - 线程创建的更快。
  - 线程更容易撤销。
  - 交换更快、耗时更短。

- 将**资源**与**调度**分开：线程作为调度的基本单位，可能会发生频繁的切换，因此不对其分配资源；进程作为拥有资源的单位，不对其进行频繁的切换，以减少切换的开销。



##### 进程与线程进行比较

- 进程是资源分配的基本单位，而线程是调度的基本单位。
- 不同的进程拥有不同的虚拟地址空间，而同意进程中的多个线程共享同一块地址空间。
- 进程的切换涉及到保存资源和地址空间的转换；线程则不需要，现成的切换开销小。
- 进程的调度与切换由操作系统完成，线程可以由用户程序进行。
- 进程和线程由创建、执行、消亡的生命周期。



##### 调度程序

- 调度：选择要运行的进程的方法。

- 调度算法

  - 非抢占式：挑选一个进程，并且让该进程运行直至被阻塞，或直到该进程自动释放CPU。
  - 抢占式：挑选一个进程，并且让该进程运行到某个固定时段的最大值。

- 常见调度算法

  - 先来先服务(FCFS)：**非抢占**

  - 最短作业优先(SJF)：有非抢占和抢占之分。

  - 最短剩余时间优先：是SJF的抢占式版本，选择剩余运行时间的进程运行。

    > 可能会有**饿死**现象，某些程序可能一直无法使用CPU。

  - 轮转调度(RR)：每个进程分配一个时间段，让该进程在该时间段内运行。

  - 优先级调度：为每一个进程赋予一个优先级，优先级最高的程序先运行。

    > 优先级可以静态或动态赋予，但有可能会发生饿死现象。

  - 多级队列：高优先级的进程运行一个时间片，次优先级的运行两个时间片，以此类推。当一个进程用完分配的时间片后，被移到下一类。



#### 进程间通信

##### 进程间通信需要解决的问题

- 一个进程如何把消息传递给另一个进程。
- 资源共享问题。
- 进程之间如何合作。



##### 基础概念

- 竞争条件：两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序。
- 互斥：以某种手段确保当一个进程读写某些共享数据时，其他进程不能做同样的操作。
- 临界区：访问共享资源的片段。
- 共享内存：拿出一块虚拟地址空间来，映射到相同的物理内存中。
- 信号量：信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。
- 锁：加锁、解锁。



##### 生产者-消费者问题

- 问题：生产者生成数据后，将数据放在缓冲区；消费者从缓冲区获取数据；一个时间内，只有一个生产者或消费者访问缓冲区。
- solution：
  - 互斥信号量 `mutex`：用于互斥访问缓冲区，初始化值为 1；
  - 资源信号量 `fullBuffers`：用于消费者询问缓冲区是否有数据，有数据则读取数据，初始化值为 0（表明缓冲区一开始为空）；
  - 资源信号量 `emptyBuffers`：用于生产者询问缓冲区是否有空位，有空位则生成数据，初始化值为 n （缓冲区大小）；



##### 哲学家就餐问题

- 问题：五个哲学家围着一张圆桌吃饭，共有五个叉子，但哲学家需要两把叉子才能吃，吃完后将叉子放回，继续思考。
- solution：
  - 让偶数编号的哲学家「先拿左边的叉子后拿右边的叉子」，奇数编号的哲学家「先拿右边的叉子后拿左边的叉子。
  - **用一个数组 state 来记录每一位哲学家的三个状态，分别是在进餐状态、思考状态、饥饿状态（正在试图拿叉子）。**那么，一个哲学家只有在两个邻居都没有进餐时，才可以进入进餐状态。



##### 读者-写者问题

- 问题：读者只会读取数据，不会修改数据，而写者即可以读也可以修改数据。
- solution:
  - 信号量 `wMutex`：控制写操作的互斥信号量，初始值为 1 ；
  - 读者计数 `rCount`：正在进行读操作的读者个数，初始化为 0；
  - 信号量 `rCountMutex`：控制对 rCount 读者计数器的互斥修改，初始值为 1；



#### 死锁

##### 基本知识

- 死锁：如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就处于死锁状态。
- 死锁的四个条件：
  - 互斥条件
  - 占有和等待条件
  - 不可抢占条件
  - 环路条件

 

##### 处理死锁的方法

- 鸵鸟算法：假装问题没有发生。
- 

