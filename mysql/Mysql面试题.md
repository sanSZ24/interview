---
typora-root-url: ./
---

<h3> Mysql面试题
</h3>

<h5>优化问题

- 定位慢查询：

  - 产生慢查询的原因：

    - 聚合查询

    - 多表查询

    - 表数据量过大查询

    - 深度分页查询

      > 表现为页面加载过慢，接口压测响应时间过长

  - 解决方式：

    - 开源工具：调试工具--Arthas，运维工具--Prometheus、Skywalking
    - Mysql自带慢日志查询：需要配置Mysql文件(调试阶段)

- 优化慢查询

  - 聚合查询:使用临时表

  - 多表查询：优化sql语句结构

  - 表数据量过大查询：添加索引

    > 可以采用explain或desc命令获取Mysql如何执行select语句的信息
    >
    > ```
    > explain select 字段 from 表 where 条件；
    > ```
    >
    > ![](/assets/%E4%BC%98%E5%8C%96.jpg)**possible_key** :当前sql可能会使用到的索引
    >
    > **key**：当前sql实际命中的索引
    >
    > **key_len**:索引占用的大小
    >
    > **type**:sql的连接类型，性能由好到差为null、system(系统自带的表)、const(主键查询)、eq_ref(主键索引查询或唯一索引查询)、ref(索引查询)、range(范围查询)、index(索引树扫描)、all(全盘扫描)。

  - 深度分页查询： 



<h5>索引
</h5>

- 索引*(index)*的概念：能够帮助mysql高效的获取数据的数据结构。InnoDB引擎通常使用B+树来实现。

  > **二叉树**:每个节点最多有两个子树的树结构。
  >
  > **红黑树**: 一种自平衡的二叉查找树
  >
  > **B树**:一颗多路平衡查找树，一般会说明其阶数，阶数m表示了一个节点最多可以有多少个孩子节点，一个节点最多可以存储m-1个key。
  >
  > **B+树**:在B树的基础上进行了优化，使其更适合实现外部存储索引结构。与B树的主要区别在于**内部节点不存储数据，只存储指针，所有的数据都存储在叶节点中**。优点主要有**磁盘读写代价低、查询效率稳定、便于扫库和区间查询**。

- 聚集索引和非聚集索引

  |    分类    | 含义                                                         | 特点                   |
  | :--------: | ------------------------------------------------------------ | ---------------------- |
  |  聚集索引  | 将数据存储与索引放到一块，索引结构的叶子节点保存的行数据     | 必须有，而且只能有一个 |
  | 非聚集索引 | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的**主键** | 可以存在多个           |

  > 回表查询：例如一张表有聚集索引**ID**和非聚集索引**name**，当执行以下sql语句时，会先去查询非聚集索引name，获得主键id后，再去查询聚集索引中查询到整行的数据，这个过程就是回表查询。
  >
  > ```
  > select * from user where name = "test";
  > ```

- 覆盖索引：查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到。**有回表查询现象的就不是覆盖索引**。

  > Mysql超大分页处理：在数据量比较大时，如果进行limit分页查询，在查询后，越往后，分页查询效率越低。
  >
  > 优化思路：一般分页查询时，通过创建**覆盖索引**能够较好地提高性能，可以通过**覆盖索引**加**子查询**形式优化。

- 索引创建的原则：

  - 数据量较大，且查询比较反复的表建立索引。
  - 常作为查询条件(where)、排序(order by)、分组(group by)操作的字段建立索引。
  - 区分度高的列作为索引，尽量建立唯一索引。
  - 字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。
  - 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。
  - 控制索引的数量，维护索引也需要付出代价。

- 索引失效的情况--explain查找失效的原因

  - 违反了最左前缀法则--使用联合索引时要从最左前列开始，并且不跳过索引中的列。

  - 范围查询右边的列，不能使用索引。

  - 在索引列上进行了运算操作，索引将失效。

  - 字符串不加单引号，造成索引失效。

  - 模糊查询可能会导致查询失效。

    

<h5>sql优化经验
</h5>

- 表的设计优化: 

  - 选择设置合适的数值
  - 设置合适的字符串类型

- 索引优化: 详见索引处的内容。

- sql语句优化: 

  - select语句指明字段名称
  - sql语句避免造成索引失效的写法
  - 使用union all 代替union，union会多一次过滤，效率低
  - 避免在where子句中对字段进行表达式操作
  - join优化: 能用inner join就不要用left join、right join；如果非要用，尽量小表放外层，大表放内层。

  

- 主从复制、读写分离: 数据库的使用场景读操作比较多的时候，为了避免写操作所造成的性能影响，可以采用该结构：

  ![主从复制，读写分离](/assets/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.jpg)

  > 主从复制的核心就是二进制日志，其中记录了所有DDL语句(create、drop等)和DML(insert、delete等)语句，但不包括数据查询(select、show)语句。**主库在事务提交时写二进制日志，从库读取该日志到中继日志中，从库重做中继日志的事务。**

  

- 分库分表: 解决存储压力。


  - 垂直拆分

    - 垂直分库: 以表为依据，根据业务将不同表拆分到不同库中。微服务项目常用，高并发下提高磁盘io和网络连接数。
    - 垂直分表: 以字段为依据，根据字段属性将不同字段拆分到不同表中。

  - 水平拆分

    - 水平分库: 将一个库的数据拆分到多个库中。主要解决数据量大和高并发的问题。
    - 水平分表: 将一个表的数据拆分到多个表中(可以在同一个库中)。


  > 分库分表的中间件：sharding-sphere和mycat。

  



<h5>事务相关
</h5>

- 事务: 是一组操作的集合，是不可分割的工作单位；会将所有的操作作为一个整体一起向系统提交或撤销的操作请求，要么一起成功，要么一起失败。

- 事务的特性：ACID。
  - **原子性(Atomicity)**: 事务是不可分割的最小操作单元。
  - **一致性(Consistency)**: 事务完成时，必须使所有的数据保持一致状态。
  - **隔离性(Isolation)**: 数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。
  - **持久性(Durability)**: 事务一旦提交或回滚，它对数据库中的数据的改变是永久的。
  
- 并发事务问题：脏读、不可重复读、幻读
  - **脏读**：一个事务读到另外一个事务还没有提交的数据。
  - **不可重复读**：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。
  - **幻读**：一个事务按条件查询数据时，没有对应的数据行，但在插入数据时，又发现该数据已存在，如同出现了“幻影”。
  
- 隔离级别：读未提交、读已提交、可重复读、串行化。隔离级别越高，性能越低。
  - 读未提交：无法解决上诉三个问题。
  - 读已提交：只能解决脏读问题。
  - 可重复读：能解决脏读和不可重复读问题，也是mysql**默认**的隔离级别。
  - 串行化：可以解决上诉三个问题，但效率较低。
  
- undo log 和redo log，mysql的日志
  
  > **缓冲池**：主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查时，先操作缓冲池中的数据，以一定频率刷新到磁盘，减少磁盘io，加快处理速度。
  >
  > **数据页**：是innoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16KB，页中存储的是行数据。
  
  
  - redo log: 重做日志，记录的是事务提交时数据也的物理修改，是**用来实现事物的持久性**。redo log是**物理日志**。
  
    > 先写日志(WAL): 处理redo log的一种方法。把buffer里的redo log先写到磁盘里，后续在恢复脏页。
  
  - undo log: 回滚日志，用于记录数据被修改前的信息，作用有两个--**提供回滚**和**MVCC(多版本并发控制)**。undo log是**逻辑日志**。可以实现事物的**一致性**和**原子性**。
  
- 锁: 数据库里主要有两种锁，共享锁和排他锁。


  - 共享锁: 只能读取数据项，多个个体可以同时拥有某个数据项的共享锁。
  - 排他锁: 能够读取和写数据项，只有一个个体能拥有某个数据项的排他锁，此时其他个体不能拥有关于这个数据项的任何锁。

- mvcc(多版本并发控制)：维护一个数据的多个版本，使得读写操作没有冲突。具体实现主要依赖数据库记录中的**隐式字段**、**undo log日志**、**readView**。


  - 隐藏字段: ![隐藏字段](/assets/%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5.jpg)

  - undo log: insert、update、delete的时候产生的便于数据回滚的日志。

    > undo log版本链：不同事务对同一条记录修改，会导致该记录的undo log生成一条记录版本链表，链表的头部的是最新的旧记录，尾部时最早修改的旧纪录。就是链表的头插法。

  - readView(读视图): 是**快照读**sql执行时mvcc提取数据的依据，记录维护系统当前活跃的事务(未提交的)id。

    > **当前读**: 读取的是记录的**最新版本**，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。
    >
    > **快照读**: 简单的select(不加锁)，读取的是记录数据的可见版本，有可能是历史数据。
    >
    > - 读已提交: 每次select都生成一格快照读。
    > - 可重复读: 开启事务后第一个select语句才是快照读的地方。

    ![mvcc](/assets/mvcc.jpg) 